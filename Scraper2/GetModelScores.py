{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Main logic\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "#from sklearn.svm import LinearSVC\n",
    "import random\n",
    "from random import randrange\n",
    "import pickle\n",
    "#from sklearn.model_selection import train_test_split\n",
    "#from sklearn.feature_extraction.text import TfidfTransformer\n",
    "#from sklearn.naive_bayes import MultinomialNB\n",
    "#from sklearn.linear_model import LogisticRegression\n",
    "#from sklearn.ensemble import RandomForestClassifier\n",
    "#from sklearn.svm import LinearSVC\n",
    "import numpy as np\n",
    "import re\n",
    "from readability import Readability\n",
    "\n",
    "## other loads \n",
    "topic_model = pickle.load(open('topicmodel.sav', 'rb'))\n",
    "topic_vectorizer = pickle.load(open('topicvectorizer.sav', 'rb'))\n",
    "\n",
    "all_subclasses= [[\"sub1_1\", \"sub1_2\", \"sub1_3\", \"sub1_4\", \"sub1_5\", \"sub1_6\", \"sub1_7\"],\n",
    "[\"sub2_1\", \"sub2_2\", \"sub2_3\", \"sub2_4\", \"sub2_5\", \"sub2_6\", \"sub2_7\", \"sub2_8\",\"sub2_9\"],\n",
    "[\"sub3_1\", \"sub3_2\", \"sub3_3\", \"sub3_4\", \"sub3_5\", \"sub3_6\", \"sub3_7\", \"sub3_8\", \"sub3_9\",\"sub3_10\"],\n",
    "[\"sub4_1\", \"sub4_2\", \"sub4_3\", \"sub4_4\", \"sub4_5\", \"sub4_6\"],\n",
    "[\"sub5_1\", \"sub5_2\", \"sub5_3\", \"sub5_4\", \"sub5_5\"],\n",
    "[\"sub6_1\", \"sub6_2\", \"sub6_3\", \"sub6_4\"]\n",
    "]\n",
    "\n",
    "# preprocess data \n",
    "\n",
    "def get_lines(body):\n",
    "    output_lines = []\n",
    "    prelines = body.replace('\\n', '. ')\n",
    "    lines = prelines.split('. ')\n",
    "    for line in lines:\n",
    "        if len(line) > 20:\n",
    "            output_lines.append(line)\n",
    "        \n",
    "    return output_lines\n",
    "\n",
    "def super_topic_classifier(line):\n",
    "    \n",
    "    vectorized = topic_vectorizer.transform([line])\n",
    "    topic = topic_model.predict(vectorized)\n",
    "    conf = topic_model.predict_proba(vectorized)\n",
    "    \n",
    "    return topic, conf\n",
    "\n",
    "\n",
    "\n",
    "def subtopic_classification(topic_lines, topic_num, subclass):\n",
    "    \n",
    "    foldername = \"./topic\" + str(topic_num) + \"models\"\n",
    "    model_filename = foldername + '/' + subclass + \"model.sav\"\n",
    "    vectorizer_filename = foldername + '/' + subclass + \"vectorizer.sav\"\n",
    "    \n",
    "    ## what kind of model logic\n",
    "    \n",
    "    subtopic_model = pickle.load(open(model_filename, 'rb'))\n",
    "    subtopic_vectorizer = pickle.load(open(vectorizer_filename, 'rb'))\n",
    "    \n",
    "    vectorized = subtopic_vectorizer.transform(topic_lines)\n",
    "    \n",
    "\n",
    "    #labels = subtopic_model.predict(vectorized)\n",
    "    confs = subtopic_model.predict_proba(vectorized)\n",
    "    \n",
    "    \n",
    "    confs_in_pos_class = confs[:,1]\n",
    "    \n",
    "    return confs_in_pos_class\n",
    "\n",
    "    \n",
    "\n",
    "def topic_classifier(topic_lines, topic_num, scores):\n",
    "\n",
    "\n",
    "    subclasses = all_subclasses[topic_num-1]\n",
    "    \n",
    "    \n",
    "    for subclass in subclasses: \n",
    "\n",
    "        if len(topic_lines) > 0:\n",
    "            max_conf = 0\n",
    "            extract = \"\"\n",
    "\n",
    "            items = [x[2] for x in topic_lines]\n",
    "\n",
    "\n",
    "            confs = subtopic_classification(items, topic_num, subclass)\n",
    "\n",
    "            max_index = np.argmax(confs)\n",
    "            max_conf = confs[max_index]\n",
    "            extract = items[max_index]\n",
    "\n",
    "            scores[subclass + \"_score\"] = max_conf\n",
    "            scores[subclass + \"_extract\"] = extract.replace('\\n',' ')\n",
    "        else:\n",
    "            scores[subclass + \"_score\"] = 0\n",
    "            scores[subclass + \"_extract\"] = \"No information found.\"\n",
    "\n",
    "\n",
    "def get_lexicon_score(body):\n",
    "    r = Readability(body)\n",
    "    \n",
    "\n",
    "    d = r.flesch()\n",
    "\n",
    "    \n",
    "    return(d.score)\n",
    "\n",
    "    \n",
    "\n",
    "def getModelScores(body):\n",
    "    \n",
    "\n",
    "    \n",
    "    scores = {}\n",
    "    \n",
    "    lines = get_lines(body)\n",
    "\n",
    "    lexicon_score = get_lexicon_score(body)\n",
    "    scores[lexicon_score] = lexicon_score\n",
    "    topic1 = []\n",
    "    topic2 = []\n",
    "    topic3 = []\n",
    "    topic4 = []\n",
    "    topic5 = []\n",
    "    topic6 = []\n",
    "    irr = []\n",
    "    \n",
    "    \n",
    "    \n",
    "    for line in lines: \n",
    "        \n",
    "        raw_topic, raw_conf = super_topic_classifier(line)\n",
    "        topic, conf = raw_topic[0]+1, raw_conf[0][int(raw_topic[0])]\n",
    "        \n",
    "        if conf > .3:\n",
    "            if str(topic) == '1':\n",
    "                topic1.append([topic, conf, line])\n",
    "\n",
    "            if str(topic) == '2':\n",
    "                topic2.append([topic, conf, line])\n",
    "\n",
    "            if str(topic) == '3':\n",
    "                topic3.append([topic, conf, line])\n",
    "\n",
    "            if str(topic) == '4':\n",
    "                topic4.append([topic, conf, line])\n",
    "\n",
    "            if str(topic) == '5':\n",
    "                topic5.append([topic, conf, line])\n",
    "\n",
    "            if str(topic) == '6':\n",
    "                topic6.append([topic, conf, line])\n",
    "        else:\n",
    "            irr.append(line)\n",
    "            \n",
    "    \n",
    "    topics = [topic1,topic2,topic3,topic4,topic5,topic6]\n",
    "\n",
    "    counter = 1\n",
    "    for topic in topics:\n",
    "        topic_classifier(topic, counter, scores)\n",
    "        counter += 1\n",
    "        \n",
    "    return scores"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
